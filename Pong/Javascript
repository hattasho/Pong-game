const canvas = document.getElementById('pongCanvas');
const ctx = canvas.getContext('2d');

// Configurações gerais
const paddleWidth = 10, paddleHeight = 100, ballSize = 10, speed = 5;
let isDragging = false, currentMouseY = 0;

// Objetos
const playerPaddle = { x: 0, y: canvas.height / 2 - paddleHeight / 2, width: paddleWidth, height: paddleHeight, color: 'white' };
const aiPaddle = { x: canvas.width - paddleWidth, y: canvas.height / 2 - paddleHeight / 2, width: paddleWidth, height: paddleHeight, color: 'white' };
const ball = { x: canvas.width / 2, y: canvas.height / 2, radius: ballSize / 2, dx: speed, dy: speed, color: 'white' };

// Desenhar objetos
function draw(obj) {
    ctx.fillStyle = obj.color;
    ctx.beginPath();
    obj.radius ? ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2) : ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    ctx.fill();
}

// Atualizações
function update() {
    ball.x += ball.dx; ball.y += ball.dy;

    // Colisão com a parede
    if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) ball.dy *= -1;

    // Colisão com paletas
    if ((ball.x - ball.radius < playerPaddle.x + playerPaddle.width && ball.y > playerPaddle.y && ball.y < playerPaddle.y + playerPaddle.height) || 
        (ball.x + ball.radius > aiPaddle.x && ball.y > aiPaddle.y && ball.y < aiPaddle.y + aiPaddle.height)) {
        ball.dx *= -1;
    }

    // Resetar bola se sair da tela
    if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
        ball.x = canvas.width / 2; ball.y = canvas.height / 2; ball.dx *= -1;
    }

    // Movimento da paleta do jogador
    if (isDragging) playerPaddle.y = Math.max(Math.min(currentMouseY - paddleHeight / 2, canvas.height - paddleHeight), 0);

    // Movimento da paleta do AI
    aiPaddle.y = Math.max(Math.min(ball.y - aiPaddle.height / 2, canvas.height - paddleHeight), 0);
}

// Eventos de arrastar
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    if (e.clientX - rect.left < playerPaddle.x + playerPaddle.width && e.clientY - rect.top > playerPaddle.y && e.clientY - rect.top < playerPaddle.y + playerPaddle.height) {
        isDragging = true;
        currentMouseY = e.clientY - rect.top;
    }
});

canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mousemove', (e) => isDragging && (currentMouseY = e.clientY - canvas.getBoundingClientRect().top));

// Loop do jogo
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    draw(playerPaddle); draw(aiPaddle); draw(ball);
    update();
    requestAnimationFrame(gameLoop);
}

gameLoop();
